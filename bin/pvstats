#!/usr/bin/env python

# Copyright 2018 Paul Archer
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import json
import logging
import time
import traceback
from datetime import datetime
import concurrent.futures
from pvstats.pvinverter.factory import PVInverterFactory
from pvstats.report import PVReportFactory

# Setup the logging
logging.basicConfig()
_log = logging.getLogger()


# Load the configuration
def load_config(location):
    with open(location) as f:
        cfg = json.load(f)

    try:
        if cfg['verbose'] > 0:
            _log.setLevel(logging.DEBUG)
    except:
        pass

    return cfg

def fetch_inverter_result(inverter):
    inverter.connect()
    inverter.read()

    return inverter

def aggregate_inverter_result(inverters):
    pass

def main():
    # Parse input arguments
    parser = argparse.ArgumentParser(
        description="Photovoltaic Inverter Statistics Scanner and Uploader",
        prog="pvstats",
        usage="%(prog)s [options]")
    parser.add_argument("--cfg", help="Configuration File", nargs=1, default="/etc/pvstats.conf")
    args = parser.parse_args()

    # Initialise
    cfg = load_config(vars(args)['cfg'][0])

    # Get an PV inverter client
    inverters = [PVInverterFactory(inverter['model'], inverter) for inverter in cfg['inverters']]

    # Create the report channels
    reports = []
    for rpt in cfg['reports']:
        _log.debug(json.dumps(rpt, sort_keys=True,
                              indent=4, separators=(',', ': '), default=str))
        r = PVReportFactory(rpt)
        if r is not None:
            reports.append(r)

    while True:
        tstart = datetime.now()
        try:
            with concurrent.futures.ThreadPoolExecutor(min(4, len(inverters))) as executor:
                futures = [executor.submit(fetch_inverter_result, inverter) for inverter in inverters]
                # Log it
                inverter_results = [inverter_future.result() for inverter_future in concurrent.futures.as_completed(futures)]
                if len(inverter_results) == 1:
                    inverter_data = inverter_results[0]
                else:
                    raise Exception('Multiple inverters')
                _log.debug(json.dumps(inverter_data.registers, sort_keys=True,
                                      indent=4, separators=(',', ': '), default=str))

                # Publish it

                for rpt in reports:
                    rpt.publish(inverter_data.registers)

        except Exception as err:
            _log.debug(traceback.format_exc())
            _log.debug("Ignoring = {}".format(err))

        finally:
            map(lambda inverter: inverter.close(), inverters)

        tend = datetime.now()
        time.sleep(max((tstart - tend).total_seconds() + cfg['sample_period'], 0))


if __name__ == "__main__":
    main()

# vim: set expandtab ts=2 sw=2:
